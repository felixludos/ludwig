[{"rep": {"title": "ChessPuzzleState", "description": "Complete, compact description of a chess position required to evaluate the best move for the side to move.", "type": "object", "required": ["fen", "board", "activeColor", "castlingRights", "enPassant", "halfmoveClock", "fullmoveNumber"], "properties": {"fen": {"type": "string", "description": "Full FEN string of the position (including side to move, castling rights, en\u2011passant square, half\u2011move clock and full\u2011move number). Serves as a unique identifier and a quick fallback representation."}, "board": {"type": "array", "description": "8\u00d78 matrix (rank 8 \u2192 1, file a \u2192 h) where each element is either null or an object describing a piece.", "items": {"type": "array", "minItems": 8, "maxItems": 8, "items": {"anyOf": [{"type": "null"}, {"type": "object", "required": ["type", "color"], "properties": {"type": {"type": "string", "enum": ["p", "n", "b", "r", "q", "k"], "description": "Piece type using lower\u2011case algebraic notation (p\u2011pawn, n\u2011knight, b\u2011bishop, r\u2011rook, q\u2011queen, k\u2011king)."}, "color": {"type": "string", "enum": ["w", "b"], "description": "Side that owns the piece: \"w\" for White, \"b\" for Black."}, "hasMoved": {"type": "boolean", "description": "True if the piece has moved at least once (relevant for king/rook castling rights and pawn double\u2011step). May be omitted if unknown; the value can be derived from FEN castling/en\u2011passant info."}}, "additionalProperties": false}]}}, "minItems": 8, "maxItems": 8}, "activeColor": {"type": "string", "enum": ["w", "b"], "description": "Side to move: \"w\" for White, \"b\" for Black. Mirrors the second field of the FEN."}, "castlingRights": {"type": "object", "description": "Availability of castling for each side. All four flags are independent; they can be recomputed from the board + hasMoved flags, but keeping them explicit speeds up move generation.", "properties": {"K": {"type": "boolean", "description": "White can castle kingside."}, "Q": {"type": "boolean", "description": "White can castle queenside."}, "k": {"type": "boolean", "description": "Black can castle kingside."}, "q": {"type": "boolean", "description": "Black can castle queenside."}}, "required": ["K", "Q", "k", "q"], "additionalProperties": false}, "enPassant": {"type": ["string", "null"], "description": "Square coordinate (e.g. \"e3\") where an en\u2011passant capture is legal on the immediate next move, or null if none."}, "halfmoveClock": {"type": "integer", "minimum": 0, "description": "Number of half\u2011moves since the last capture or pawn advance \u2013 required for the fifty\u2011move rule."}, "fullmoveNumber": {"type": "integer", "minimum": 1, "description": "Current full move number (incremented after Black's move)."}, "metadata": {"type": "object", "description": "Optional auxiliary information useful for search but not needed for legality.", "properties": {"moveHistory": {"type": "array", "description": "Sequence of SAN/UCI moves that led to this position (useful for repetition detection).", "items": {"type": "string"}}, "evaluationCache": {"type": "object", "description": "Cache for previously computed static evaluations; keys are strings describing the position (e.g., Zobrist hash) and values are numeric scores.", "additionalProperties": {"type": "number"}}}, "additionalProperties": false}}, "additionalProperties": false}, "example": {"fen": "r2q1rk1/ppp2ppp/2n1bn2/3p4/3P4/2N1PN2/PPP2PPP/R1BQKB1R w KQ - 2 9", "board": [[{"type": "r", "color": "b"}, null, null, {"type": "q", "color": "b"}, null, {"type": "r", "color": "b"}, {"type": "k", "color": "b"}, null], [{"type": "p", "color": "b"}, {"type": "p", "color": "b"}, {"type": "p", "color": "b"}, null, null, {"type": "p", "color": "b"}, {"type": "p", "color": "b"}, {"type": "p", "color": "b"}], [null, null, {"type": "n", "color": "b"}, null, {"type": "b", "color": "b"}, {"type": "n", "color": "b"}, null, null], [null, null, null, {"type": "p", "color": "b"}, null, null, null, null], [null, null, null, {"type": "p", "color": "w"}, null, null, null, null], [null, null, {"type": "n", "color": "w"}, null, {"type": "p", "color": "w"}, {"type": "n", "color": "w"}, null, null], [{"type": "p", "color": "w"}, {"type": "p", "color": "w"}, {"type": "p", "color": "w"}, null, null, {"type": "p", "color": "w"}, {"type": "p", "color": "w"}, {"type": "p", "color": "w"}], [{"type": "r", "color": "w"}, null, {"type": "b", "color": "w"}, {"type": "q", "color": "w"}, {"type": "k", "color": "w"}, {"type": "b", "color": "w"}, null, {"type": "r", "color": "w"}]], "activeColor": "w", "castlingRights": {"K": true, "Q": true, "k": false, "q": false}, "enPassant": null, "halfmoveClock": 2, "fullmoveNumber": 9, "metadata": {"moveHistory": []}}, "encode": "import json\nfrom typing import Dict, Any\n\ndef encode(fen_string: str) -> Dict[str, Any]:\n    \"\"\"\n    Converts a chess position from Forsyth-Edwards Notation (FEN)\n    into a structured dictionary format.\n\n    Args:\n        fen_string: A string representing the chess position in FEN.\n\n    Returns:\n        A dictionary that conforms to the ChessPuzzleState JSON schema.\n    \"\"\"\n    # FEN string is composed of 6 fields separated by spaces.\n    (\n        piece_placement,\n        active_color,\n        castling,\n        en_passant,\n        halfmove_clock,\n        fullmove_number,\n    ) = fen_string.split()\n\n    # --- 1. Board Representation ---\n    # Create the 8x8 board from the piece placement field.\n    board = []\n    ranks = piece_placement.split('/')\n    for rank_str in ranks:\n        rank = []\n        for char in rank_str:\n            if char.isdigit():\n                # Add `None` for empty squares.\n                rank.extend([None] * int(char))\n            else:\n                # Add a piece object for occupied squares.\n                piece = {\n                    \"type\": char.lower(),\n                    \"color\": \"w\" if char.isupper() else \"b\"\n                }\n                rank.append(piece)\n        board.append(rank)\n\n    # --- 2. Castling Rights ---\n    # Create a boolean map for castling availability.\n    castling_rights = {\n        \"K\": \"K\" in castling,\n        \"Q\": \"Q\" in castling,\n        \"k\": \"k\" in castling,\n        \"q\": \"q\" in castling,\n    }\n\n    # --- 3. En Passant Square ---\n    # Set to the square coordinate or None if not available.\n    en_passant_square = None if en_passant == \"-\" else en_passant\n\n    # --- 4. Assemble Final State Object ---\n    # Combine all parsed data into the final dictionary.\n    state = {\n        \"fen\": fen_string,\n        \"board\": board,\n        \"activeColor\": active_color,\n        \"castlingRights\": castling_rights,\n        \"enPassant\": en_passant_square,\n        \"halfmoveClock\": int(halfmove_clock),\n        \"fullmoveNumber\": int(fullmove_number),\n    }\n\n    return state", "decode": "from typing import Dict, Any\n\ndef decode(state: Dict[str, Any]) -> str:\n    \"\"\"\n    Converts a JSON-like chess state representation into a FEN string.\n\n    Args:\n        state: A dictionary representing the chess position, conforming to the\n               specified input schema.\n\n    Returns:\n        The FEN (Forsyth-Edwards Notation) string for the given position.\n    \"\"\"\n    # 1. Piece Placement\n    board_fen_parts = []\n    for row in state['board']:\n        rank_fen = \"\"\n        empty_squares = 0\n        for piece in row:\n            if piece is None:\n                empty_squares += 1\n            else:\n                if empty_squares > 0:\n                    rank_fen += str(empty_squares)\n                    empty_squares = 0\n                \n                piece_char = piece['type']\n                if piece['color'] == 'w':\n                    rank_fen += piece_char.upper()\n                else:\n                    rank_fen += piece_char.lower()\n        \n        if empty_squares > 0:\n            rank_fen += str(empty_squares)\n        \n        board_fen_parts.append(rank_fen)\n    \n    piece_placement = \"/\".join(board_fen_parts)\n    \n    # 2. Active Color\n    active_color = state['activeColor']\n    \n    # 3. Castling Rights\n    rights = state['castlingRights']\n    castling_fen = \"\"\n    if rights.get('K'): castling_fen += 'K'\n    if rights.get('Q'): castling_fen += 'Q'\n    if rights.get('k'): castling_fen += 'k'\n    if rights.get('q'): castling_fen += 'q'\n    if not castling_fen:\n        castling_fen = '-'\n        \n    # 4. En Passant Target Square\n    en_passant = state['enPassant'] if state['enPassant'] is not None else '-'\n    \n    # 5. Halfmove Clock & 6. Fullmove Number\n    halfmove_clock = str(state['halfmoveClock'])\n    fullmove_number = str(state['fullmoveNumber'])\n    \n    # Assemble the final FEN string\n    return \" \".join([\n        piece_placement,\n        active_color,\n        castling_fen,\n        en_passant,\n        halfmove_clock,\n        fullmove_number\n    ])"}, {"rep": {"title": "ChessPuzzleState", "description": "Compact, high\u2011fidelity representation of a chess puzzle position used for tree\u2011search solving.", "type": "object", "required": ["board", "activeColor", "castlingRights", "enPassant", "halfmoveClock", "fullmoveNumber", "moveHistory"], "properties": {"board": {"description": "8\u00d78 array (rank 8 \u2192 1, file a \u2192 h) of piece codes. Empty squares are null. Piece codes are two\u2011character strings: first character is color ('w' or 'b'), second is piece type ('K','Q','R','B','N','P').", "type": "array", "minItems": 8, "maxItems": 8, "items": {"type": "array", "minItems": 8, "maxItems": 8, "items": {"anyOf": [{"type": "null"}, {"type": "string"}]}}}, "activeColor": {"description": "Side to move: 'w' for White, 'b' for Black.", "type": "string", "enum": ["w", "b"]}, "castlingRights": {"description": "Castling availability for each side. Empty string means no castling rights. Otherwise contains any of 'K' (White king\u2011side), 'Q' (White queen\u2011side), 'k' (Black king\u2011side), 'q' (Black queen\u2011side).", "type": "string"}, "enPassant": {"description": "Square where an en\u2011passant capture is possible, expressed in algebraic notation (e.g., 'e3'). Null if no en\u2011passant target exists.", "type": ["string", "null"]}, "halfmoveClock": {"description": "Number of half\u2011moves since the last capture or pawn advance (for the 50\u2011move rule).", "type": "integer", "minimum": 0}, "fullmoveNumber": {"description": "Number of the full move (incremented after Black's move).", "type": "integer", "minimum": 1}, "moveHistory": {"description": "Chronological list of the moves already played in the puzzle, stored as SAN strings. Useful for detecting three\u2011fold repetition and for debugging; it does not affect legality checks beyond repetition detection.", "type": "array", "items": {"type": "string"}}, "metadata": {"description": "Optional auxiliary information (e.g., puzzle ID, source, time control). Not used by the solver but retained for bookkeeping.", "type": "object", "additionalProperties": true}}, "additionalProperties": false}, "example": {"board": [["bR", null, "bB", "bQ", null, "bR", "bK", null], ["bP", "bP", null, null, "bB", "bP", "bP", "bP"], [null, null, "bN", "bP", "bP", "bN", null, null], [null, null, "bP", null, "wP", null, null, null], [null, null, "wB", "wP", null, null, null, null], [null, null, null, "wQ", null, "wN", null, null], ["wP", "wP", "wP", null, "wB", "wP", "wP", "wP"], ["wR", "wN", null, null, null, "wR", "wK", null]], "activeColor": "b", "castlingRights": "", "enPassant": null, "halfmoveClock": 3, "fullmoveNumber": 23, "moveHistory": ["e4", "c5", "Nf3", "d6", "Bc4", "e6", "O-O", "Nf6", "d4", "cxd4", "Nxd4", "Be7", "Be2", "O-O", "f4", "Qc7", "f5", "exf5", "Nf3", "b6"]}, "encode": "import json\n\ndef encode(fen_string: str) -> dict:\n    \"\"\"\n    Converts a chess position from Forsyth-Edwards Notation (FEN) to a\n    dictionary conforming to the ChessPuzzleState JSON schema.\n\n    Args:\n        fen_string: The FEN string representing the chess state.\n\n    Returns:\n        A dictionary representing the state.\n    \"\"\"\n    parts = fen_string.split()\n    \n    # 1. Parse the board layout\n    board = []\n    for rank_str in parts[0].split('/'):\n        rank = []\n        for char in rank_str:\n            if char.isdigit():\n                # Add null for empty squares\n                rank.extend([None] * int(char))\n            else:\n                # Determine color and piece type\n                color = 'w' if char.isupper() else 'b'\n                piece_type = char.upper()\n                rank.append(f\"{color}{piece_type}\")\n        board.append(rank)\n\n    # 2. Extract other game state information\n    active_color = parts[1]\n    castling_rights = parts[2] if parts[2] != '-' else ''\n    en_passant = parts[3] if parts[3] != '-' else None\n    halfmove_clock = int(parts[4])\n    fullmove_number = int(parts[5])\n\n    # 3. Assemble the final state object\n    return {\n        \"board\": board,\n        \"activeColor\": active_color,\n        \"castlingRights\": castling_rights,\n        \"enPassant\": en_passant,\n        \"halfmoveClock\": halfmove_clock,\n        \"fullmoveNumber\": fullmove_number,\n        \"moveHistory\": []  # FEN does not contain move history\n    }", "decode": "from typing import Dict, Any\n\ndef decode(state: Dict[str, Any]) -> str:\n    \"\"\"\n    Converts a chess puzzle state from a JSON-like dictionary to a \n    Forsyth-Edwards Notation (FEN) string.\n\n    Args:\n        state: A dictionary representing the chess position.\n\n    Returns:\n        A FEN string representing the position.\n    \"\"\"\n    fen_parts = []\n\n    # 1. Piece Placement\n    rank_strings = []\n    for rank in state['board']:\n        empty_squares = 0\n        rank_fen = \"\"\n        for piece in rank:\n            if piece is None:\n                empty_squares += 1\n            else:\n                if empty_squares > 0:\n                    rank_fen += str(empty_squares)\n                    empty_squares = 0\n                \n                color = piece[0]\n                piece_type = piece[1]\n                \n                # White pieces are uppercase, black are lowercase.\n                fen_char = piece_type if color == 'w' else piece_type.lower()\n                rank_fen += fen_char\n        \n        # Append count of trailing empty squares\n        if empty_squares > 0:\n            rank_fen += str(empty_squares)\n        \n        rank_strings.append(rank_fen)\n        \n    board_fen = \"/\".join(rank_strings)\n    fen_parts.append(board_fen)\n\n    # 2. Active Color\n    fen_parts.append(state['activeColor'])\n\n    # 3. Castling Rights\n    castling = state['castlingRights']\n    fen_parts.append(castling if castling else \"-\")\n\n    # 4. En Passant Target Square\n    en_passant = state['enPassant']\n    fen_parts.append(en_passant if en_passant is not None else \"-\")\n\n    # 5. Halfmove Clock\n    fen_parts.append(str(state['halfmoveClock']))\n\n    # 6. Fullmove Number\n    fen_parts.append(str(state['fullmoveNumber']))\n\n    return \" \".join(fen_parts)"}, {"rep": {"title": "ChessPuzzleState", "description": "Compact, unambiguous representation of a chess position that contains everything needed to generate legal moves, evaluate the position and back\u2011track during search.", "type": "object", "required": ["fen", "board", "sideToMove", "castlingRights", "enPassant", "halfmoveClock", "fullmoveNumber"], "additionalProperties": false, "properties": {"fen": {"type": "string", "description": "Full FEN string of the position (includes board, side to move, castling, en\u2011passant, half\u2011move clock and full\u2011move number)."}, "board": {"type": "array", "description": "8\u2011element array (rank 8 \u2192 1). Each element is an 8\u2011character string describing the squares of that rank using the standard FEN piece symbols (uppercase = White, lowercase = Black, \u20181\u2019\u2026\u20188\u2019 compression may be used).", "items": {"type": "string", "minLength": 1, "maxLength": 8}, "minItems": 8, "maxItems": 8}, "sideToMove": {"type": "string", "enum": ["w", "b"], "description": "Whose turn it is: 'w' for White, 'b' for Black."}, "castlingRights": {"type": "string", "description": "Castling availability as in FEN (any combination of KQkq or '-' if none)."}, "enPassant": {"type": "string", "description": "En\u2011passant target square in algebraic notation or '-' if none."}, "halfmoveClock": {"type": "integer", "minimum": 0, "description": "Number of half\u2011moves since the last capture or pawn advance (for 50\u2011move rule)."}, "fullmoveNumber": {"type": "integer", "minimum": 1, "description": "Full move counter (incremented after Black's move)."}, "pieceList": {"type": "array", "description": "Optional explicit list of pieces to make move generation cheap. Each entry describes one piece.", "items": {"type": "object", "required": ["type", "color", "square"], "additionalProperties": false, "properties": {"type": {"type": "string", "enum": ["p", "n", "b", "r", "q", "k"], "description": "Piece type, lower\u2011case (regardless of colour)."}, "color": {"type": "string", "enum": ["w", "b"], "description": "Piece colour."}, "square": {"type": "string", "description": "Algebraic square where the piece sits."}}}}, "moveHistory": {"type": "array", "description": "Sequence of moves already played from the start of the puzzle (useful for three\u2011fold repetition detection).", "items": {"type": "string", "description": "Move in UCI notation (e.g., 'e2e4', 'e7e8q')."}}, "metadata": {"type": "object", "description": "Auxiliary data that does not affect legality but may aid search (e.g., puzzle ID, author notes).", "additionalProperties": true}}}, "example": {"fen": "rnbq1rk1/pp2b1pp/2p1pn2/1N1pP3/2BP4/2PQ1N2/PP2B1PP/R4RK1 w - - 3 14", "board": ["rnbq1rk1", "pp2b1pp", "2p1pn2", "1N1pP3", "2BP4", "2PQ1N2", "PP2B1PP", "R4RK1"], "sideToMove": "w", "castlingRights": "-", "enPassant": "-", "halfmoveClock": 3, "fullmoveNumber": 14, "pieceList": [{"type": "k", "color": "w", "square": "g1"}, {"type": "q", "color": "w", "square": "d3"}, {"type": "r", "color": "w", "square": "a1"}, {"type": "r", "color": "w", "square": "f1"}, {"type": "b", "color": "w", "square": "c4"}, {"type": "b", "color": "w", "square": "e2"}, {"type": "n", "color": "w", "square": "b5"}, {"type": "n", "color": "w", "square": "f3"}, {"type": "p", "color": "w", "square": "a2"}, {"type": "p", "color": "w", "square": "b2"}, {"type": "p", "color": "w", "square": "c3"}, {"type": "p", "color": "w", "square": "d4"}, {"type": "p", "color": "w", "square": "e5"}, {"type": "p", "color": "w", "square": "g2"}, {"type": "p", "color": "w", "square": "h2"}, {"type": "k", "color": "b", "square": "g8"}, {"type": "q", "color": "b", "square": "d8"}, {"type": "r", "color": "b", "square": "a8"}, {"type": "r", "color": "b", "square": "f8"}, {"type": "b", "color": "b", "square": "c8"}, {"type": "b", "color": "b", "square": "e7"}, {"type": "n", "color": "b", "square": "b8"}, {"type": "n", "color": "b", "square": "f6"}, {"type": "p", "color": "b", "square": "a7"}, {"type": "p", "color": "b", "square": "b7"}, {"type": "p", "color": "b", "square": "c6"}, {"type": "p", "color": "b", "square": "d5"}, {"type": "p", "color": "b", "square": "e6"}, {"type": "p", "color": "b", "square": "g7"}, {"type": "p", "color": "b", "square": "h7"}], "moveHistory": ["e2e4", "e7e5", "Nf3", "Nc6", "Bb5", "a6", "Ba4", "Nf6"], "metadata": {"description": "Random mid\u2011game position generated for demonstration purposes.", "generatedAt": "2025-09-26T12:34:56Z"}}, "encode": "import json\n\ndef encode(fen_string: str) -> dict:\n    \"\"\"\n    Converts a FEN string into a dictionary that conforms to the ChessPuzzleState schema.\n\n    Args:\n        fen_string: A standard Forsyth-Edwards Notation (FEN) string.\n\n    Returns:\n        A dictionary representing the chess position.\n    \"\"\"\n    # Split the FEN string into its six components.\n    parts = fen_string.split(' ')\n\n    # Parse each component according to the schema.\n    board_state = parts[0].split('/')\n    side_to_move = parts[1]\n    castling_rights = parts[2]\n    en_passant_target = parts[3]\n    halfmove_clock = int(parts[4])\n    fullmove_number = int(parts[5])\n\n    # Construct the dictionary.\n    state = {\n        \"fen\": fen_string,\n        \"board\": board_state,\n        \"sideToMove\": side_to_move,\n        \"castlingRights\": castling_rights,\n        \"enPassant\": en_passant_target,\n        \"halfmoveClock\": halfmove_clock,\n        \"fullmoveNumber\": fullmove_number\n    }\n\n    return state", "decode": "from typing import Dict, Any\n\ndef decode(state: Dict[str, Any]) -> str:\n    \"\"\"\n    Converts a chess puzzle state dictionary into its FEN string representation.\n\n    This function constructs the FEN string by assembling the six required\n    components (board, side to move, castling rights, en passant square,\n    halfmove clock, and fullmove number) from the input dictionary.\n\n    Args:\n        state: A dictionary representing the chess position, which must\n               contain the keys 'board', 'sideToMove', 'castlingRights',\n               'enPassant', 'halfmoveClock', and 'fullmoveNumber'.\n\n    Returns:\n        The full FEN string corresponding to the given state.\n    \"\"\"\n    # Assemble the six parts of the FEN string from the dictionary.\n    fen_parts = [\n        \"/\".join(state[\"board\"]),\n        state[\"sideToMove\"],\n        state[\"castlingRights\"],\n        state[\"enPassant\"],\n        str(state[\"halfmoveClock\"]),\n        str(state[\"fullmoveNumber\"])\n    ]\n    \n    # Join the parts with spaces to form the final FEN string.\n    return \" \".join(fen_parts)"}, {"rep": {"title": "ChessPuzzleState", "description": "Complete, minimal representation of a chess position needed to evaluate and generate legal moves for a puzzle solver.", "type": "object", "required": ["board", "activeColor", "castlingRights", "halfmoveClock", "fullmoveNumber"], "additionalProperties": false, "properties": {"board": {"description": "Array of 8 strings (rank 8 \u2192 rank 1). Each string contains exactly 8 characters using the standard FEN piece symbols (PNBRQK for White, pnbrqk for Black) or the placeholder '.' for an empty square.", "type": "array", "minItems": 8, "maxItems": 8, "items": {"type": "string"}}, "activeColor": {"description": "Side to move: 'w' for White, 'b' for Black.", "type": "string", "enum": ["w", "b"]}, "castlingRights": {"description": "Four\u2011character string indicating which castling rights are still available. Uses the standard FEN notation (any subset of 'KQkq'). A dash '-' means no castling rights.", "type": "string"}, "enPassantTarget": {"description": "Square on which an en\u2011passant capture is possible (e.g., 'e3'), or null if none. The square is given in algebraic notation and is always on rank 3 (if Black to move) or rank 6 (if White to move).", "type": ["string", "null"]}, "halfmoveClock": {"description": "Number of half\u2011moves (plies) since the last pawn move or capture. Required for the 50\u2011move draw rule; not needed for move generation but part of a full FEN.", "type": "integer", "minimum": 0}, "fullmoveNumber": {"description": "The full move number (starting at 1). Increments after Black's move.", "type": "integer", "minimum": 1}, "moveHistory": {"description": "Optional list of previously played moves in SAN. Stored purely for debugging or for puzzles that need the sequence of moves; it does not affect legality of the current position.", "type": "array", "items": {"type": "string"}}, "metadata": {"description": "Optional free\u2011form object for auxiliary information (e.g., puzzle ID, source, difficulty rating). It is ignored by the search algorithm.", "type": "object", "additionalProperties": true}}}, "example": {"board": ["rnbqkbnr", "pppppppp", "........", "....P...", "...p....", "........", "PPPP.PPP", "RNBQKBNR"], "activeColor": "w", "castlingRights": "KQkq", "enPassantTarget": null, "halfmoveClock": 0, "fullmoveNumber": 1}, "encode": "import json\n\ndef encode(fen: str) -> dict:\n    \"\"\"\n    Converts a FEN string into a dictionary that conforms to the ChessPuzzleState schema.\n\n    Args:\n        fen: A standard Forsyth-Edwards Notation (FEN) string.\n\n    Returns:\n        A dictionary representing the chess position.\n    \"\"\"\n    parts = fen.split()\n    \n    # 1. Process the board layout\n    board_fen = parts[0]\n    board = []\n    for rank_fen in board_fen.split('/'):\n        rank_str = \"\"\n        for char in rank_fen:\n            if char.isdigit():\n                rank_str += '.' * int(char)\n            else:\n                rank_str += char\n        board.append(rank_str)\n\n    # 2. Extract other game state information\n    active_color = parts[1]\n    castling_rights = parts[2]\n    en_passant_target = parts[3] if parts[3] != '-' else None\n    halfmove_clock = int(parts[4])\n    fullmove_number = int(parts[5])\n\n    # 3. Assemble the final state dictionary\n    state = {\n        \"board\": board,\n        \"activeColor\": active_color,\n        \"castlingRights\": castling_rights,\n        \"halfmoveClock\": halfmove_clock,\n        \"fullmoveNumber\": fullmove_number\n    }\n    \n    # Conditionally add enPassantTarget if it's not None\n    if en_passant_target:\n        state[\"enPassantTarget\"] = en_passant_target\n\n    return state", "decode": "import json\n\ndef decode(state: dict) -> str:\n    \"\"\"\n    Converts a dictionary representing a chess state into its FEN string.\n\n    Args:\n        state: A dictionary conforming to the ChessPuzzleState JSON schema,\n               representing the chess position.\n\n    Returns:\n        The Forsyth-Edwards Notation (FEN) string for the given state.\n    \"\"\"\n    \n    # 1. Process the board layout\n    # Iterates through each rank, converting consecutive empty squares ('.')\n    # into a number and keeping piece characters as they are.\n    fen_ranks = []\n    for rank_str in state['board']:\n        fen_rank = \"\"\n        empty_count = 0\n        for piece in rank_str:\n            if piece == '.':\n                empty_count += 1\n            else:\n                if empty_count > 0:\n                    fen_rank += str(empty_count)\n                fen_rank += piece\n                empty_count = 0\n        # Append any trailing empty square count\n        if empty_count > 0:\n            fen_rank += str(empty_count)\n        fen_ranks.append(fen_rank)\n    board_fen = \"/\".join(fen_ranks)\n\n    # 2. Extract remaining FEN fields from the state dictionary\n    active_color = state['activeColor']\n    \n    # Default to '-' if castling rights are not specified or are null/empty\n    castling_rights = state.get('castlingRights') or '-'\n    \n    # Default to '-' if en passant target is not specified or is null\n    en_passant_target = state.get('enPassantTarget') or '-'\n    \n    halfmove_clock = str(state['halfmoveClock'])\n    fullmove_number = str(state['fullmoveNumber'])\n\n    # 3. Assemble the final FEN string with fields separated by spaces\n    fen_string = \" \".join([\n        board_fen,\n        active_color,\n        castling_rights,\n        en_passant_target,\n        halfmove_clock,\n        fullmove_number\n    ])\n    \n    return fen_string"}, {"rep": {"title": "ChessPuzzleState", "description": "Compact, high\u2011fidelity representation of a chess position for use in a tree\u2011search solver.", "type": "object", "required": ["fen", "sideToMove", "board", "castlingRights", "enPassantSquare", "halfmoveClock", "fullmoveNumber"], "properties": {"fen": {"type": "string", "description": "Full FEN string of the position (includes board, side to move, castling, en\u2011passant, half\u2011move clock and full\u2011move number)."}, "sideToMove": {"type": "string", "enum": ["w", "b"], "description": "Whose turn it is to move: 'w' for White, 'b' for Black."}, "board": {"type": "array", "description": "8\u00d78 array (rank 8 \u2192 1, file a \u2192 h) storing a piece code or null for empty squares.", "items": {"type": "array", "items": {"anyOf": [{"type": "null", "description": "Empty square."}, {"type": "string", "enum": ["P", "N", "B", "R", "Q", "K", "p", "n", "b", "r", "q", "k"], "description": "Standard piece codes: uppercase = White, lowercase = Black."}]}, "minItems": 8, "maxItems": 8}, "minItems": 8, "maxItems": 8}, "castlingRights": {"type": "object", "description": "Availability of castling for each side; true = still possible, false = lost.", "properties": {"whiteKingSide": {"type": "boolean", "default": false}, "whiteQueenSide": {"type": "boolean", "default": false}, "blackKingSide": {"type": "boolean", "default": false}, "blackQueenSide": {"type": "boolean", "default": false}}, "required": ["whiteKingSide", "whiteQueenSide", "blackKingSide", "blackQueenSide"], "additionalProperties": false}, "enPassantSquare": {"type": ["string", "null"], "description": "Algebraic coordinate (e.g., \"e3\") of a possible en\u2011passant capture square, or null if none."}, "halfmoveClock": {"type": "integer", "minimum": 0, "description": "Number of half\u2011moves since the last pawn advance or capture (used for the 50\u2011move rule)."}, "fullmoveNumber": {"type": "integer", "minimum": 1, "description": "The full move number (incremented after Black's move)."}, "moveHistory": {"type": "array", "description": "Optional list of moves already played in SAN notation \u2013 useful for repetition detection.", "items": {"type": "string"}}, "evaluation": {"type": ["number", "null"], "description": "Engine evaluation of the position from the side to move\u2019s perspective (centipawns), or null if not yet computed.", "minimum": -10000, "maximum": 10000}, "searchDepth": {"type": "integer", "description": "Depth from the root node at which this state occurs (0 for the initial puzzle state).", "minimum": 0, "default": 0}, "parentMove": {"type": ["string", "null"], "description": "The move (SAN or UCI) that led from the parent node to this state; null for the root.", "default": null}}, "additionalProperties": false}, "example": {"fen": "r1bqkbnr/pppp1ppp/2n5/4p3/2B1P3/5N2/PPPP1PPP/RNBQK2R b KQkq - 2 3", "sideToMove": "b", "board": [["r", null, "b", "q", "k", "b", "n", "r"], ["p", "p", "p", "p", null, "p", "p", "p"], [null, null, "n", null, null, null, null, null], [null, null, null, null, "p", null, null, null], [null, null, "B", null, "P", null, null, null], [null, null, null, null, null, "N", null, null], ["P", "P", "P", "P", null, "P", "P", "P"], ["R", "N", "B", "Q", "K", null, null, "R"]], "castlingRights": {"whiteKingSide": true, "whiteQueenSide": true, "blackKingSide": true, "blackQueenSide": true}, "enPassantSquare": null, "halfmoveClock": 2, "fullmoveNumber": 3}, "encode": "import json\nfrom typing import Dict, Any, List, Optional\n\ndef encode(fen: str) -> Dict[str, Any]:\n    \"\"\"\n    Converts a chess position from Forsyth-Edwards Notation (FEN) to a\n    structured dictionary format.\n\n    Args:\n        fen: A valid FEN string representing the chess position.\n\n    Returns:\n        A dictionary matching the specified ChessPuzzleState JSON schema.\n    \"\"\"\n    parts = fen.split()\n    (\n        piece_placement,\n        side_to_move,\n        castling_str,\n        en_passant_str,\n        halfmove_clock_str,\n        fullmove_number_str,\n    ) = parts\n\n    # 1. Parse the board layout\n    board: List[List[Optional[str]]] = []\n    ranks = piece_placement.split('/')\n    for rank_str in ranks:\n        row: List[Optional[str]] = []\n        for char in rank_str:\n            if char.isdigit():\n                # Add empty squares for numeric values\n                row.extend([None] * int(char))\n            else:\n                # Add the piece character\n                row.append(char)\n        board.append(row)\n\n    # 2. Parse castling rights\n    castling_rights = {\n        \"whiteKingSide\": \"K\" in castling_str,\n        \"whiteQueenSide\": \"Q\" in castling_str,\n        \"blackKingSide\": \"k\" in castling_str,\n        \"blackQueenSide\": \"q\" in castling_str,\n    }\n\n    # 3. Parse the en passant square\n    en_passant_square = None if en_passant_str == \"-\" else en_passant_str\n\n    # 4. Assemble the final state object\n    state = {\n        \"fen\": fen,\n        \"sideToMove\": side_to_move,\n        \"board\": board,\n        \"castlingRights\": castling_rights,\n        \"enPassantSquare\": en_passant_square,\n        \"halfmoveClock\": int(halfmove_clock_str),\n        \"fullmoveNumber\": int(fullmove_number_str),\n    }\n\n    return state", "decode": "from typing import Dict, Any\n\ndef decode(state: Dict[str, Any]) -> str:\n    \"\"\"\n    Converts a JSON-like chess state representation into a FEN string.\n\n    Args:\n        state: A dictionary representing the chess position.\n\n    Returns:\n        The FEN string representation of the position.\n    \"\"\"\n    \n    # 1. Process piece placement from the board\n    board_ranks = []\n    for rank in state['board']:\n        empty_squares = 0\n        rank_str = \"\"\n        for piece in rank:\n            if piece is None:\n                empty_squares += 1\n            else:\n                if empty_squares > 0:\n                    rank_str += str(empty_squares)\n                    empty_squares = 0\n                rank_str += piece\n        if empty_squares > 0:\n            rank_str += str(empty_squares)\n        board_ranks.append(rank_str)\n    board_fen = \"/\".join(board_ranks)\n\n    # 2. Get the active color\n    side_to_move_fen = state['sideToMove']\n\n    # 3. Determine castling availability\n    castling_fen = \"\"\n    cr = state['castlingRights']\n    if cr['whiteKingSide']:\n        castling_fen += 'K'\n    if cr['whiteQueenSide']:\n        castling_fen += 'Q'\n    if cr['blackKingSide']:\n        castling_fen += 'k'\n    if cr['blackQueenSide']:\n        castling_fen += 'q'\n    if not castling_fen:\n        castling_fen = '-'\n\n    # 4. Determine en passant target square\n    en_passant_fen = state['enPassantSquare'] if state['enPassantSquare'] is not None else '-'\n\n    # 5. Get the halfmove clock\n    halfmove_clock_fen = str(state['halfmoveClock'])\n\n    # 6. Get the fullmove number\n    fullmove_number_fen = str(state['fullmoveNumber'])\n\n    # Assemble the final FEN string with all six fields\n    return f\"{board_fen} {side_to_move_fen} {castling_fen} {en_passant_fen} {halfmove_clock_fen} {fullmove_number_fen}\""}, {"rep": {"title": "ChessPuzzleState", "description": "Compact, high\u2011fidelity representation of a chess position for use in a tree\u2011search solver.", "type": "object", "required": ["fen", "turn", "castlingRights", "enPassantSquare", "halfmoveClock", "fullmoveNumber", "pieceMap", "kingSquares", "moveHistory"], "properties": {"fen": {"type": "string", "description": "Full FEN of the position (including side to move, castling rights, en\u2011passant target, half\u2011move clock and full\u2011move number). This is the canonical source of truth."}, "turn": {"type": "string", "enum": ["w", "b"], "description": "Side to move: 'w' for White, 'b' for Black. Duplicates the information in the FEN but is kept for fast access."}, "castlingRights": {"type": "object", "description": "Available castling rights for each side. Stored as booleans for quick legality checks.", "required": ["whiteKingside", "whiteQueenside", "blackKingside", "blackQueenside"], "properties": {"whiteKingside": {"type": "boolean"}, "whiteQueenside": {"type": "boolean"}, "blackKingside": {"type": "boolean"}, "blackQueenside": {"type": "boolean"}}, "additionalProperties": false}, "enPassantSquare": {"type": ["string", "null"], "description": "Square on which an en\u2011passant capture is possible (e.g., \"e3\"). Null if no en\u2011passant target exists."}, "halfmoveClock": {"type": "integer", "minimum": 0, "description": "Number of half\u2011moves since the last pawn advance or capture (for the fifty\u2011move rule)."}, "fullmoveNumber": {"type": "integer", "minimum": 1, "description": "Full\u2011move number as defined by the FEN spec."}, "pieceMap": {"type": "object", "description": "Mapping from board squares (e.g., \"e4\") to piece codes. Piece codes follow the UCI convention: 'P','N','B','R','Q','K' for White and lower\u2011case 'p','n','b','r','q','k' for Black.", "patternProperties": {"^[a-h][1-8]$": {"type": "string", "enum": ["P", "N", "B", "R", "Q", "K", "p", "n", "b", "r", "q", "k"]}}, "additionalProperties": false, "minProperties": 2, "maxProperties": 32}, "kingSquares": {"type": "object", "description": "Explicit locations of the two kings for O(1) check detection.", "required": ["w", "b"], "properties": {"w": {"type": "string", "description": "White king square."}, "b": {"type": "string", "description": "Black king square."}}, "additionalProperties": false}, "moveHistory": {"type": "array", "description": "List of previously played moves in SAN (or UCI) order. Used for threefold\u2011repetition detection and for reporting the solution path. Each entry is a string.", "items": {"type": "string"}}, "metadata": {"type": "object", "description": "Optional auxiliary data that does not affect move legality but may assist the search (e.g., heuristic scores).", "properties": {"evaluation": {"type": "number", "description": "Engine evaluation of the position (from the side to move's perspective)."}, "depth": {"type": "integer", "minimum": 0, "description": "Depth of this node in the search tree."}}, "additionalProperties": true}}, "additionalProperties": false}, "example": {"fen": "r1bqkbnr/pppp1ppp/2n5/4p3/3P4/5N2/PPP1PPPP/RNBQKB1R b KQkq - 2 3", "turn": "b", "castlingRights": {"whiteKingside": true, "whiteQueenside": true, "blackKingside": true, "blackQueenside": true}, "enPassantSquare": null, "halfmoveClock": 2, "fullmoveNumber": 3, "pieceMap": {"a8": "r", "c8": "b", "d8": "q", "e8": "k", "f8": "b", "g8": "n", "h8": "r", "a7": "p", "b7": "p", "c7": "p", "d7": "p", "f7": "p", "g7": "p", "h7": "p", "c6": "n", "e5": "p", "d4": "P", "f3": "N", "a2": "P", "b2": "P", "c2": "P", "e2": "P", "f2": "P", "g2": "P", "h2": "P", "a1": "R", "b1": "N", "c1": "B", "d1": "Q", "e1": "K", "f1": "B", "h1": "R"}, "kingSquares": {"w": "e1", "b": "e8"}, "moveHistory": ["e4", "e5", "Nf3", "Nc6"], "metadata": {"evaluation": 0.3, "depth": 0}}, "encode": "def encode(fen_string: str) -> dict:\n    \"\"\"\n    Converts a Forsyth-Edwards Notation (FEN) string into a dictionary\n    that matches the specified ChessPuzzleState JSON schema.\n\n    Args:\n        fen_string: A valid FEN string representing a chess position.\n\n    Returns:\n        A dictionary containing a detailed representation of the chess state.\n    \"\"\"\n    # Split the FEN string into its 6 constituent fields.\n    (\n        piece_placement,\n        turn,\n        castling,\n        en_passant,\n        halfmove_clock,\n        fullmove_number,\n    ) = fen_string.split(\" \")\n\n    # --- Process Piece Placement ---\n    piece_map = {}\n    king_squares = {}\n    # FEN ranks are listed from 8 down to 1.\n    for rank_idx, rank_str in enumerate(piece_placement.split(\"/\")):\n        rank = 8 - rank_idx\n        file_idx = 0\n        for char in rank_str:\n            if char.isdigit():\n                # A digit indicates a number of empty squares.\n                file_idx += int(char)\n            else:\n                # A letter indicates a piece.\n                file = \"abcdefgh\"[file_idx]\n                square = f\"{file}{rank}\"\n                piece_map[square] = char\n\n                # Record the position of the kings for quick access.\n                if char == \"K\":\n                    king_squares[\"w\"] = square\n                elif char == \"k\":\n                    king_squares[\"b\"] = square\n\n                file_idx += 1\n\n    # --- Process Other FEN Fields ---\n    # Determine castling rights from the castling field.\n    castling_rights = {\n        \"whiteKingside\": \"K\" in castling,\n        \"whiteQueenside\": \"Q\" in castling,\n        \"blackKingside\": \"k\" in castling,\n        \"blackQueenside\": \"q\" in castling,\n    }\n\n    # Set the en passant square, or None if not applicable.\n    en_passant_square = None if en_passant == \"-\" else en_passant\n\n    # --- Assemble the Final State Dictionary ---\n    # The FEN string itself does not contain move history.\n    # Per the schema, `moveHistory` is a required field, so we default to an empty list.\n    state = {\n        \"fen\": fen_string,\n        \"turn\": turn,\n        \"castlingRights\": castling_rights,\n        \"enPassantSquare\": en_passant_square,\n        \"halfmoveClock\": int(halfmove_clock),\n        \"fullmoveNumber\": int(fullmove_number),\n        \"pieceMap\": piece_map,\n        \"kingSquares\": king_squares,\n        \"moveHistory\": [],\n    }\n\n    return state", "decode": "from typing import Any, Dict\n\ndef decode(state: Dict[str, Any]) -> str:\n    \"\"\"\n    Converts a chess puzzle state dictionary into its FEN string representation.\n\n    The function accesses the 'fen' key in the input dictionary, which,\n    according to the provided schema, is the canonical source of truth for\n    the position's FEN string.\n\n    Args:\n        state: A dictionary representing the chess position, conforming to the\n               specified INPUT JSON schema.\n\n    Returns:\n        The FEN string for the given state.\n    \"\"\"\n    return state['fen']"}, {"rep": {"title": "ChessPuzzleState", "description": "Compact, loss\u2011less representation of a chess position that contains every detail required to evaluate moves and to perform a tree\u2011search for the best continuation.", "type": "object", "required": ["fen", "turn", "castling", "enPassant", "halfmoveClock", "fullmoveNumber", "board"], "additionalProperties": false, "properties": {"fen": {"type": "string", "description": "Full FEN string of the position (includes piece placement, active color, castling rights, en\u2011passant square, half\u2011move clock and full\u2011move number). This serves as a canonical textual snapshot and can be used for hashing or debugging."}, "turn": {"type": "string", "enum": ["w", "b"], "description": "Side to move: \"w\" for White, \"b\" for Black. Redundant with the active\u2011color field of the FEN but kept for quick access."}, "castling": {"type": "string", "description": "Castling rights in standard FEN notation (any combination of KQkq or \"-\" if none). Mirrors the castling portion of the FEN."}, "enPassant": {"type": "string", "description": "En\u2011passant target square (e.g., \"e3\") if a pawn has just moved two squares, otherwise \"-\"."}, "halfmoveClock": {"type": "integer", "minimum": 0, "description": "Number of half\u2011moves since the last capture or pawn advance (for the fifty\u2011move draw rule)."}, "fullmoveNumber": {"type": "integer", "minimum": 1, "description": "Full move counter as defined by FEN (incremented after Black's move)."}, "board": {"type": "array", "description": "A 8\u00d78 matrix describing each square. The first array element corresponds to rank\u202f8, file\u202fa (a8). Each square is an object describing the occupying piece or null for empty.", "items": {"type": "array", "minItems": 8, "maxItems": 8, "items": {"anyOf": [{"type": "null", "description": "Empty square."}, {"type": "object", "required": ["type", "color"], "additionalProperties": false, "properties": {"type": {"type": "string", "enum": ["p", "n", "b", "r", "q", "k"], "description": "Piece type using lowercase algebraic notation (p = pawn, n = knight, b = bishop, r = rook, q = queen, k = king)."}, "color": {"type": "string", "enum": ["w", "b"], "description": "Piece colour: \"w\" for White, \"b\" for Black."}}}]}}}, "moveHistory": {"type": "array", "description": "Optional list of moves already played in SAN format, useful for puzzles that require a specific move count or for debugging. Not required for solving a single\u2011move puzzle.", "items": {"type": "string", "description": "Move in standard algebraic notation (SAN)."}}, "metadata": {"type": "object", "description": "Optional auxiliary information (e.g., puzzle ID, source, difficulty). Ignored by the search algorithm.", "additionalProperties": true}}}, "example": {"fen": "r1bqkbnr/pppp1ppp/2n5/4p3/2B1P3/5N2/PPPP1PPP/RNBQK2R b KQkq - 2 3", "turn": "b", "castling": "KQkq", "enPassant": "-", "halfmoveClock": 2, "fullmoveNumber": 3, "board": [[{"type": "r", "color": "b"}, null, {"type": "b", "color": "b"}, {"type": "q", "color": "b"}, {"type": "k", "color": "b"}, {"type": "b", "color": "b"}, {"type": "n", "color": "b"}, {"type": "r", "color": "b"}], [{"type": "p", "color": "b"}, {"type": "p", "color": "b"}, {"type": "p", "color": "b"}, {"type": "p", "color": "b"}, null, {"type": "p", "color": "b"}, {"type": "p", "color": "b"}, {"type": "p", "color": "b"}], [null, null, {"type": "n", "color": "b"}, null, null, null, null, null], [null, null, null, null, {"type": "p", "color": "b"}, null, null, null], [null, null, {"type": "b", "color": "w"}, null, {"type": "p", "color": "w"}, null, null, null], [null, null, null, null, null, {"type": "n", "color": "w"}, null, null], [{"type": "p", "color": "w"}, {"type": "p", "color": "w"}, {"type": "p", "color": "w"}, {"type": "p", "color": "w"}, null, {"type": "p", "color": "w"}, {"type": "p", "color": "w"}, {"type": "p", "color": "w"}], [{"type": "r", "color": "w"}, {"type": "n", "color": "w"}, {"type": "b", "color": "w"}, {"type": "q", "color": "w"}, {"type": "k", "color": "w"}, null, null, {"type": "r", "color": "w"}]], "moveHistory": ["e4", "e5", "Nf3"], "metadata": {"puzzleId": "random-midgame-001", "source": "generated", "difficulty": "medium"}}, "encode": "import json\nfrom typing import Dict, List, Any, Optional\n\ndef encode(fen_string: str) -> Dict[str, Any]:\n    \"\"\"\n    Converts a chess position from a FEN string to a structured dictionary.\n\n    Args:\n        fen_string: The standard FEN representation of the chess position.\n\n    Returns:\n        A dictionary matching the specified ChessPuzzleState JSON schema.\n    \"\"\"\n    # 1. Split the FEN string into its six component fields.\n    (\n        piece_placement,\n        turn,\n        castling,\n        en_passant,\n        halfmove_clock,\n        fullmove_number,\n    ) = fen_string.split(\" \")\n\n    # 2. Parse the piece placement string to create the 8x8 board matrix.\n    board: List[List[Optional[Dict[str, str]]]] = []\n    ranks = piece_placement.split(\"/\")\n\n    for rank_str in ranks:\n        row: List[Optional[Dict[str, str]]] = []\n        for char in rank_str:\n            if char.isdigit():\n                # If the character is a digit, add that many empty squares (None).\n                row.extend([None] * int(char))\n            else:\n                # Otherwise, it's a piece. Determine its color and type.\n                color = \"w\" if char.isupper() else \"b\"\n                piece_type = char.lower()\n                row.append({\"type\": piece_type, \"color\": color})\n        board.append(row)\n\n    # 3. Assemble the final dictionary with all parsed data.\n    state = {\n        \"fen\": fen_string,\n        \"turn\": turn,\n        \"castling\": castling,\n        \"enPassant\": en_passant,\n        \"halfmoveClock\": int(halfmove_clock),\n        \"fullmoveNumber\": int(fullmove_number),\n        \"board\": board,\n    }\n\n    return state", "decode": "from typing import Dict, Any\n\ndef decode(state: Dict[str, Any]) -> str:\n    \"\"\"\n    Converts a chess puzzle state from a dictionary format to its FEN string.\n\n    The input dictionary contains a complete FEN string under the key \"fen\",\n    which this function directly returns as the desired output format.\n\n    Args:\n        state: A dictionary representing the chess position, which includes\n               a \"fen\" key with the full FEN string.\n\n    Returns:\n        The FEN string of the chess position.\n    \"\"\"\n    return state[\"fen\"]"}, {"rep": {"title": "ChessPuzzleState", "description": "Compact, high\u2011fidelity representation of a chess position for puzzle\u2011solving search algorithms.", "type": "object", "required": ["fen", "turn", "board"], "additionalProperties": false, "properties": {"fen": {"type": "string", "description": "Full Forsyth\u2011Edwards Notation string for the position (e.g. \"r5k1/Rp3p1p/2b2qp1/3pr3/8/4P2P/2PN1PP1/Q3K2R b K - 0 19\"). All information needed to reconstruct the position is contained in this field."}, "turn": {"type": "string", "enum": ["w", "b"], "description": "Side to move: \"w\" for White, \"b\" for Black. Mirrors the turn field in the FEN but is kept separate for quick access during search."}, "castling": {"type": "object", "description": "Explicit castling rights for each side. Redundant with the FEN but convenient for fast legality checks.", "required": ["whiteKingside", "whiteQueenside", "blackKingside", "blackQueenside"], "additionalProperties": false, "properties": {"whiteKingside": {"type": "boolean", "description": "True if White may castle kingside."}, "whiteQueenside": {"type": "boolean", "description": "True if White may castle queenside."}, "blackKingside": {"type": "boolean", "description": "True if Black may castle kingside."}, "blackQueenside": {"type": "boolean", "description": "True if Black may castle queenside."}}}, "enPassant": {"type": ["string", "null"], "description": "Target square for en\u2011passant capture (e.g. \"e3\"). Null if no en\u2011passant target exists."}, "halfmoveClock": {"type": "integer", "minimum": 0, "description": "Number of half\u2011moves since the last pawn advance or capture (for the fifty\u2011move rule)."}, "fullmoveNumber": {"type": "integer", "minimum": 1, "description": "Count of full moves in the game. Increments after Black's move."}, "board": {"type": "array", "description": "List of pieces currently on the board. Each entry gives piece type, colour and square. This representation avoids parsing the FEN repeatedly during node expansion.", "items": {"type": "object", "required": ["type", "color", "square"], "additionalProperties": false, "properties": {"type": {"type": "string", "enum": ["K", "Q", "R", "B", "N", "P"], "description": "Piece type using standard algebraic notation (uppercase)."}, "color": {"type": "string", "enum": ["w", "b"], "description": "Colour of the piece."}, "square": {"type": "string", "description": "Square the piece occupies, in algebraic notation."}}}, "minItems": 2}, "metadata": {"type": "object", "description": "Optional auxiliary information useful for the search algorithm but not required for legal\u2011move generation.", "additionalProperties": true, "properties": {"depth": {"type": "integer", "minimum": 0, "description": "Depth of this node in the search tree (root = 0)."}, "parentMove": {"type": "string", "description": "SAN or UCI move that led to this position from its parent. Allows reconstruction of the solution line."}, "evaluation": {"type": "number", "description": "Stored evaluation score (e.g., centipawns) if previously computed."}}}}}, "example": {"fen": "r2q1rk1/pppb1ppp/2n1pn2/3p4/3P4/2N1PN2/PPPB1PPP/R2QKB1R w KQ - 3 12", "turn": "w", "castling": {"whiteKingside": true, "whiteQueenside": true, "blackKingside": false, "blackQueenside": false}, "enPassant": null, "halfmoveClock": 3, "fullmoveNumber": 12, "board": [{"type": "K", "color": "w", "square": "e1"}, {"type": "Q", "color": "w", "square": "d1"}, {"type": "R", "color": "w", "square": "a1"}, {"type": "R", "color": "w", "square": "h1"}, {"type": "B", "color": "w", "square": "f1"}, {"type": "B", "color": "w", "square": "d2"}, {"type": "N", "color": "w", "square": "c3"}, {"type": "N", "color": "w", "square": "f3"}, {"type": "P", "color": "w", "square": "a2"}, {"type": "P", "color": "w", "square": "b2"}, {"type": "P", "color": "w", "square": "c2"}, {"type": "P", "color": "w", "square": "d4"}, {"type": "P", "color": "w", "square": "e3"}, {"type": "P", "color": "w", "square": "f2"}, {"type": "P", "color": "w", "square": "g2"}, {"type": "P", "color": "w", "square": "h2"}, {"type": "K", "color": "b", "square": "g8"}, {"type": "Q", "color": "b", "square": "d8"}, {"type": "R", "color": "b", "square": "a8"}, {"type": "R", "color": "b", "square": "f8"}, {"type": "B", "color": "b", "square": "d7"}, {"type": "N", "color": "b", "square": "c6"}, {"type": "N", "color": "b", "square": "f6"}, {"type": "P", "color": "b", "square": "a7"}, {"type": "P", "color": "b", "square": "b7"}, {"type": "P", "color": "b", "square": "c7"}, {"type": "P", "color": "b", "square": "d5"}, {"type": "P", "color": "b", "square": "e6"}, {"type": "P", "color": "b", "square": "f7"}, {"type": "P", "color": "b", "square": "g7"}, {"type": "P", "color": "b", "square": "h7"}], "metadata": {"depth": 0, "parentMove": null, "evaluation": null}}, "encode": "def encode(fen: str) -> dict:\n    \"\"\"\n    Converts a FEN string into a dictionary representation that matches\n    the ChessPuzzleState JSON schema.\n\n    Args:\n        fen: A valid Forsyth-Edwards Notation (FEN) string.\n\n    Returns:\n        A dictionary representing the chess position.\n    \"\"\"\n    # Split the FEN string into its six standard components\n    parts = fen.split()\n    (\n        placement,\n        turn,\n        castling_str,\n        en_passant_str,\n        halfmove_clock_str,\n        fullmove_number_str,\n    ) = parts\n\n    # --- 1. Parse the board piece placement ---\n    board = []\n    # FEN ranks are from 8th to 1st, separated by '/'\n    for rank_index, rank_str in enumerate(placement.split('/')):\n        rank_num = 8 - rank_index\n        col_index = 0\n        for char in rank_str:\n            if char.isdigit():\n                # A digit indicates a number of empty squares\n                col_index += int(char)\n            else:\n                # A letter indicates a piece\n                piece_color = 'w' if char.isupper() else 'b'\n                piece_type = char.upper()\n                file_char = chr(ord('a') + col_index)\n                square = f\"{file_char}{rank_num}\"\n\n                board.append({\n                    \"type\": piece_type,\n                    \"color\": piece_color,\n                    \"square\": square,\n                })\n                col_index += 1\n\n    # --- 2. Parse castling rights ---\n    castling = {\n        \"whiteKingside\": 'K' in castling_str,\n        \"whiteQueenside\": 'Q' in castling_str,\n        \"blackKingside\": 'k' in castling_str,\n        \"blackQueenside\": 'q' in castling_str,\n    }\n\n    # --- 3. Parse en-passant target square ---\n    # The value is null if the FEN string has a '-'\n    en_passant = None if en_passant_str == '-' else en_passant_str\n\n    # --- 4. Assemble the final state object ---\n    state = {\n        \"fen\": fen,\n        \"turn\": turn,\n        \"board\": board,\n        \"castling\": castling,\n        \"enPassant\": en_passant,\n        \"halfmoveClock\": int(halfmove_clock_str),\n        \"fullmoveNumber\": int(fullmove_number_str),\n    }\n\n    return state", "decode": "from typing import Dict, Any\n\ndef decode(state: Dict[str, Any]) -> str:\n    \"\"\"\n    Converts a JSON chess puzzle state into its FEN string representation.\n\n    Args:\n        state: A dictionary representing the chess position, conforming to the \n               specified INPUT schema. It must contain the 'fen' key.\n\n    Returns:\n        The FEN string representing the chess position.\n    \"\"\"\n    return state[\"fen\"]"}, {"rep": {"title": "ChessPuzzleState", "description": "Complete representation of a chess position required to determine the best move for the side to move in a puzzle.", "type": "object", "required": ["board", "activeColor", "castlingRights", "enPassantSquare", "halfmoveClock", "fullmoveNumber"], "properties": {"board": {"description": "8\u00d78 array (rank 8 to 1, file a to h) with each element describing the piece on that square or null if empty.", "type": "array", "items": {"type": "array", "minItems": 8, "maxItems": 8, "items": {"anyOf": [{"type": "null", "description": "Empty square."}, {"type": "object", "description": "A single chess piece.", "required": ["type", "color"], "properties": {"type": {"type": "string", "enum": ["K", "Q", "R", "B", "N", "P"], "description": "Piece type: King, Queen, Rook, Bishop, Knight, Pawn."}, "color": {"type": "string", "enum": ["w", "b"], "description": "Piece color: 'w' for white, 'b' for black."}}, "additionalProperties": false}]}}, "minItems": 8, "maxItems": 8}, "activeColor": {"description": "Side to move.", "type": "string", "enum": ["w", "b"]}, "castlingRights": {"description": "Available castling options for both sides, expressed as a four\u2011character string like the FEN field (KQkq) or '-' if none.", "type": "string", "minLength": 1, "maxLength": 4}, "enPassantSquare": {"description": "Square on which an en\u2011passant capture is possible (e.g., \"e3\"), or null if not available.", "type": ["string", "null"], "default": null}, "halfmoveClock": {"description": "Number of half\u2011moves since the last capture or pawn move (for the fifty\u2011move rule).", "type": "integer", "minimum": 0}, "fullmoveNumber": {"description": "Current fullmove number (starts at 1 and increments after Black's move).", "type": "integer", "minimum": 1}, "moveHistory": {"description": "Optional list of previous moves in SAN, useful for advanced evaluation (e.g., repetition).", "type": "array", "items": {"type": "string"}}, "metadata": {"description": "Optional auxiliary data that does not affect legality but may guide heuristics (e.g., puzzle ID, depth limit).", "type": "object", "additionalProperties": true}}, "additionalProperties": false}, "example": {"board": [[{"type": "R", "color": "b"}, {"type": "N", "color": "b"}, {"type": "B", "color": "b"}, {"type": "Q", "color": "b"}, {"type": "K", "color": "b"}, null, {"type": "N", "color": "b"}, {"type": "R", "color": "b"}], [{"type": "P", "color": "b"}, {"type": "P", "color": "b"}, {"type": "P", "color": "b"}, null, null, {"type": "P", "color": "b"}, {"type": "P", "color": "b"}, {"type": "P", "color": "b"}], [null, null, null, {"type": "B", "color": "b"}, null, null, null, null], [null, null, null, {"type": "P", "color": "w"}, {"type": "P", "color": "b"}, null, null, null], [null, null, {"type": "B", "color": "w"}, null, {"type": "P", "color": "w"}, null, null, null], [null, null, {"type": "N", "color": "w"}, null, null, {"type": "N", "color": "w"}, null, null], [{"type": "P", "color": "w"}, {"type": "P", "color": "w"}, {"type": "P", "color": "w"}, {"type": "Q", "color": "w"}, null, {"type": "P", "color": "w"}, {"type": "P", "color": "w"}, {"type": "P", "color": "w"}], [{"type": "R", "color": "w"}, null, {"type": "B", "color": "w"}, null, {"type": "K", "color": "w"}, null, null, {"type": "R", "color": "w"}]], "activeColor": "w", "castlingRights": "KQkq", "enPassantSquare": null, "halfmoveClock": 0, "fullmoveNumber": 12}, "encode": "def encode(fen_string: str) -> dict:\n    \"\"\"\n    Converts a FEN string representation of a chess state into a dictionary\n    that matches the specified JSON schema.\n\n    Args:\n        fen_string: The FEN string representing the chess position.\n\n    Returns:\n        A dictionary containing the structured state of the chess puzzle.\n    \"\"\"\n    # Split the FEN string into its 6 components\n    (\n        piece_placement,\n        active_color,\n        castling,\n        en_passant,\n        halfmove,\n        fullmove,\n    ) = fen_string.split(\" \")\n\n    # --- 1. Parse the board layout ---\n    board = []\n    # Process each rank from 8 down to 1\n    for fen_rank in piece_placement.split(\"/\"):\n        rank_list = []\n        for char in fen_rank:\n            if char.isdigit():\n                # Add N `None` objects for empty squares\n                rank_list.extend([None] * int(char))\n            else:\n                # Determine color and type for a piece\n                color = \"w\" if char.isupper() else \"b\"\n                piece_type = char.upper()\n                rank_list.append({\"type\": piece_type, \"color\": color})\n        board.append(rank_list)\n\n    # --- 2. Handle the En Passant square ---\n    # Convert '-' to None as per the schema\n    en_passant_square = None if en_passant == \"-\" else en_passant\n\n    # --- 3. Assemble the final state dictionary ---\n    state = {\n        \"board\": board,\n        \"activeColor\": active_color,\n        \"castlingRights\": castling,\n        \"enPassantSquare\": en_passant_square,\n        \"halfmoveClock\": int(halfmove),\n        \"fullmoveNumber\": int(fullmove),\n    }\n\n    return state", "decode": "from typing import Dict, Any, List, Optional\n\ndef decode(state: Dict[str, Any]) -> str:\n    \"\"\"\n    Converts a chess position from a JSON-like dictionary format to a\n    Forsyth-Edwards Notation (FEN) string.\n\n    Args:\n        state: A dictionary representing the chess position, conforming to the\n               specified schema.\n\n    Returns:\n        The FEN string representation of the given position.\n    \"\"\"\n    \n    # 1. Piece Placement\n    board_ranks: List[str] = []\n    board_data: List[List[Optional[Dict[str, str]]]] = state['board']\n    \n    for rank in board_data:\n        fen_rank = \"\"\n        empty_squares = 0\n        for square in rank:\n            if square is None:\n                empty_squares += 1\n            else:\n                if empty_squares > 0:\n                    fen_rank += str(empty_squares)\n                    empty_squares = 0\n                \n                piece_type: str = square['type']\n                piece_color: str = square['color']\n                \n                if piece_color == 'w':\n                    fen_rank += piece_type.upper()\n                else:\n                    fen_rank += piece_type.lower()\n        \n        if empty_squares > 0:\n            fen_rank += str(empty_squares)\n        \n        board_ranks.append(fen_rank)\n        \n    piece_placement = \"/\".join(board_ranks)\n\n    # 2. Active Color\n    active_color: str = state['activeColor']\n\n    # 3. Castling Rights\n    castling_rights: str = state['castlingRights'] if state['castlingRights'] else \"-\"\n\n    # 4. En Passant Target Square\n    en_passant_square: str = state['enPassantSquare'] if state['enPassantSquare'] is not None else \"-\"\n\n    # 5. Halfmove Clock\n    halfmove_clock: str = str(state['halfmoveClock'])\n\n    # 6. Fullmove Number\n    fullmove_number: str = str(state['fullmoveNumber'])\n\n    # Combine all parts into the final FEN string\n    return \" \".join([\n        piece_placement,\n        active_color,\n        castling_rights,\n        en_passant_square,\n        halfmove_clock,\n        fullmove_number\n    ])"}, {"rep": {"title": "ChessPuzzleState", "description": "Compact, high\u2011fidelity representation of a chess puzzle suitable for tree\u2011search algorithms.", "type": "object", "required": ["board", "activeColor", "castlingRights", "enPassant", "halfmoveClock", "fullmoveNumber", "solutionInfo"], "additionalProperties": false, "properties": {"board": {"description": "8\u00d78 array (rank 8 \u2192 rank 1, file a \u2192 file h) containing a piece code or null for empty squares.", "type": "array", "minItems": 8, "maxItems": 8, "items": {"type": "array", "minItems": 8, "maxItems": 8, "items": {"anyOf": [{"type": "null", "description": "Empty square"}, {"type": "string", "description": "Single\u2011character piece code (uppercase = White, lowercase = Black).", "enum": ["K", "Q", "R", "B", "N", "P", "k", "q", "r", "b", "n", "p"]}]}}}, "activeColor": {"description": "Side to move.", "type": "string", "enum": ["w", "b"]}, "castlingRights": {"description": "Availability of castling for each side, expressed as a 4\u2011character string. '-' indicates no right.", "type": "string"}, "enPassant": {"description": "Target square for en\u2011passant capture in algebraic notation (e.g., \"e3\"). Null if no en\u2011passant square is available.", "type": ["string", "null"]}, "halfmoveClock": {"description": "Number of half\u2011moves since the last pawn advance or capture (for fifty\u2011move rule).", "type": "integer", "minimum": 0}, "fullmoveNumber": {"description": "Current full move number (starts at 1 and increments after Black's move).", "type": "integer", "minimum": 1}, "solutionInfo": {"description": "Metadata required for answer validation and scoring.", "type": "object", "required": ["requestedFormat"], "additionalProperties": false, "properties": {"requestedFormat": {"description": "Desired output format for the best move.", "type": "string", "enum": ["UCI", "SAN"]}, "moveNumber": {"description": "Ply count of the position (optional, helpful for puzzles with multiple moves).", "type": "integer", "minimum": 1}, "maxDepth": {"description": "Maximum search depth allowed for the puzzle (optional).", "type": "integer", "minimum": 1}}}, "metadata": {"description": "Optional non\u2011essential information (source, puzzle ID, etc.). Ignored by the search algorithm.", "type": "object", "additionalProperties": {"type": "string"}}}}, "example": {"board": [["r", "n", "b", "q", "k", "b", "n", "r"], ["p", "p", "p", null, "p", "p", "p", "p"], [null, null, null, "p", null, null, null, null], [null, null, "N", null, null, null, null, null], [null, null, null, null, "P", null, null, null], [null, null, null, null, null, "N", null, null], ["P", "P", "P", "P", null, "P", "P", "P"], ["R", "N", "B", "Q", "K", "B", null, "R"]], "activeColor": "w", "castlingRights": "KQkq", "enPassant": null, "halfmoveClock": 0, "fullmoveNumber": 12, "solutionInfo": {"requestedFormat": "UCI", "moveNumber": 23, "maxDepth": 5}, "metadata": {"source": "randomly_generated", "id": "example-001"}}, "encode": "import json\nfrom typing import Dict, Any\n\ndef encode(fen_string: str) -> Dict[str, Any]:\n    \"\"\"\n    Converts a chess position from Forsyth-Edwards Notation (FEN)\n    to a dictionary matching the specified JSON schema.\n\n    Args:\n        fen_string: A standard FEN string representing a chess position.\n\n    Returns:\n        A dictionary representation of the chess state.\n    \"\"\"\n    # Split the FEN string into its six component parts\n    parts = fen_string.split()\n    piece_placement, active_color, castling, en_passant, halfmove, fullmove = parts\n\n    # 1. Parse the board layout (piece placement)\n    board = []\n    ranks = piece_placement.split('/')\n    for rank_str in ranks:\n        row = []\n        for char in rank_str:\n            if char.isdigit():\n                # Add null for empty squares\n                row.extend([None] * int(char))\n            else:\n                # Add the piece character\n                row.append(char)\n        board.append(row)\n\n    # 2. Parse the remaining FEN fields\n    # En passant square is None if FEN has a '-', otherwise it's the square string\n    en_passant_square = None if en_passant == '-' else en_passant\n\n    # The solutionInfo field is required by the schema but not present in FEN.\n    # We provide a default value.\n    solution_info = {\"requestedFormat\": \"UCI\"}\n\n    # 3. Assemble the final state dictionary\n    state = {\n        \"board\": board,\n        \"activeColor\": active_color,\n        \"castlingRights\": castling,\n        \"enPassant\": en_passant_square,\n        \"halfmoveClock\": int(halfmove),\n        \"fullmoveNumber\": int(fullmove),\n        \"solutionInfo\": solution_info\n    }\n\n    return state", "decode": "def decode(state: dict) -> str:\n    \"\"\"\n    Converts a chess puzzle state from a JSON-like dictionary format\n    to a standard Forsyth-Edwards Notation (FEN) string.\n\n    Args:\n        state: A dictionary representing the chess position, conforming\n               to the specified input schema.\n\n    Returns:\n        A FEN string representing the given chess position.\n    \"\"\"\n    # 1. Process the board representation\n    fen_board_rows = []\n    for row in state['board']:\n        fen_row = ''\n        empty_count = 0\n        for piece in row:\n            if piece is None:\n                empty_count += 1\n            else:\n                if empty_count > 0:\n                    fen_row += str(empty_count)\n                    empty_count = 0\n                fen_row += piece\n        if empty_count > 0:\n            fen_row += str(empty_count)\n        fen_board_rows.append(fen_row)\n    piece_placement = '/'.join(fen_board_rows)\n\n    # 2. Extract other game state information\n    active_color = state['activeColor']\n    # Use the castling string directly, or '-' if it's empty\n    castling_rights = state['castlingRights'] if state['castlingRights'] else '-'\n    # Use the algebraic notation for the en passant square, or '-' if null\n    en_passant_target = state['enPassant'] if state['enPassant'] is not None else '-'\n    halfmove_clock = str(state['halfmoveClock'])\n    fullmove_number = str(state['fullmoveNumber'])\n\n    # 3. Assemble the final FEN string\n    fen_string = f\"{piece_placement} {active_color} {castling_rights} {en_passant_target} {halfmove_clock} {fullmove_number}\"\n    \n    return fen_string"}]